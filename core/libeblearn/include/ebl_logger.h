/***************************************************************************
 *   Copyright (C) 2008 by Yann LeCun and Pierre Sermanet *
 *   yann@cs.nyu.edu, pierre.sermanet@gmail.com *
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Redistribution under a license not approved by the Open Source
 *       Initiative (http://www.opensource.org) must display the
 *       following acknowledgement in all advertising material:
 *        This product includes software developed at the Courant
 *        Institute of Mathematical Sciences (http://cims.nyu.edu).
 *     * The names of the authors may not be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL ThE AUTHORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ***************************************************************************/

#ifndef EBL_LOGGER_H_
#define EBL_LOGGER_H_

#include "libidx.h"
#include "ebl_defines.h"

#ifndef __NOSTL__
#include <vector>
#endif

namespace ebl {

////////////////////////////////////////////////////////////////

//! a special kind of state used to store the output of a classifier.
//! class-state are generated by modules such as class-max, and used
//! by meters such as classifier-meter. No backprop is possible through
//! a class-state.
class class_state {
 public:
  ubyte output_class;
  float confidence;
  idx<ubyte> *sorted_classes;
  idx<float> *sorted_scores;

  class_state(ubyte n);
  ~class_state();
  void resize(ubyte n);
};

////////////////////////////////////////////////////////////////
//! Meters are classes used to measure the performance
//! of learning machines. There are several types
//! of meters for each specific situation.
//! meters are generally assumed to have at least
//! the following methods:
//! {<ul>
//!  {<li> update: updates the meter with the objects
//!        and values passed as argument.}
//!  {<li> clear: resets the meter, so it can be used
//!        for a new series of measurements.}
//!  {<li> test: simply prints performance information
//!        for the data passed as argument. This
//!        does not update any internal state.}
//! }
//! Methods are provided to compute and display the
//! information measured by a meter.
//! {<ul>
//!  {<li> display: display performance information on the terminal}
//!  {<li> info: returns a list of the informations printed by display}
//! }

//! a class that can be used to measure the performance of
//! classifiers. This is a simple version that does not
//! record anything but simply computes performance measures.
// TODO: allow definition of different comparison functions.
class EXPORT classifier_meter {
public:
  //! Create a new <classifier-meter> using <comparison-function>
  //! to compare actual and desired answers. By default
  //! the <same-class?> function is used for that purpose.
  //! It takes two integer arguments, and returns 1 if they
  //! are equal, -1 if they are different, and 0 if
  //! the first argument is -1 (which means reject).
  // TODO: allow passing of comparison function
  classifier_meter();

  //! Destructor.
  ~classifier_meter();

  //! Initialize the meter.
  //! \param nclasses The number of classes.
  void init(uint nclasses);

  //! return 0 if <actual> equals -1, otherwise, return 1 if <actual>
  //! and <desired> are equal, -1 otherwise.
  int correctp(ubyte co, ubyte cd);

  //! reset the meter. This must be called
  //! before a measurement campaign is started.
  void clear();
  void resize(intg sz);

  //! update the meter with results from a new sample.
  //! <age> is the number of training iterations so far,
  //! <actual> (a <class-state>) the actual output of the machine,
  //! <desired> (an idx0 of int) the desired category,
  //! and <energy> (an idx0-state) the energy.
  char update(intg a, class_state *co, ubyte cd, double energy);
  void update(intg age_, bool correct, double energy);
  // TODO: clean up design
  // TODO: add confusion matrix computation
  void update(intg age, uint desired, uint infered, double energy);

  void test(class_state *co, ubyte cd, double energy);

  //! Returns the average error percentage computed from the confusion matrix,
  //! i.e. taking into account the class distributions, in other words,
  //! returns the mean of the per-class mean error.
  double class_normalized_average_error(idx<int> &confu);

  //! Returns the average error percentage computed regardless of the class.
  //! This measure might be bias with unbalanced datasets.
  double overall_average_error(idx<int> &confu);

  //! Returns the average success percentage computed
  //! from the confusion matrix 'confu'.
  double class_normalized_average_success(idx<int> &confu);

  //! Return the number of samples for class with id 'classid'
  //! in confusion matrix 'confu'.
  int get_class_samples(idx<int> &confu, intg classid);

  //! Return the number of errors for class with id 'classid'
  //! in confusion matrix 'confu'.
  int get_class_errors(idx<int> &confu, intg classid);
  //! Returns the error rate, normalized by the number of examples of in each
  //! class.
  double get_normalized_error();
  //! Returns the confusion matrix;
  idx<int>& get_confusion();

  //! return a list with the age, the number of samples
  //! (number of calls to update since the last clear),
  //! the average energy, the percentage of correctly
  //! recognize samples, the percentage of erroneously
  //! recognized samples, and the percentage of rejected samples.
  void info();
  void info_sprint();
  void info_print();

  //! Display the meter's information on the terminal.
  //! namely, the age, the number of samples
  //! (number of calls to update since the last clear),
  //! the average energy, the percentage of correctly
  //! recognize samples, the percentage of erroneously
  //! recognized samples, and the percentage of rejected samples.
  //! names of each class (lblstr) are optional.
  //! \param ds_is_test If true, prepend "test_" in front of varialbes.
  void display(int iteration, std::string &dsname,
               std::vector<std::string*> *lblstr = NULL,
               bool ds_is_test = false);

  //! Display information averaged over all iterations.
  void display_average(std::string &dsname,
                       std::vector<std::string*> *lblstr = NULL,
                       bool ds_is_test = false);

  //! display ROC points for each class.
  //! names of each class (lblstr) are optional.
  void display_positive_rates(double threshold,
                              std::vector<std::string*> *lblstr = NULL);

  bool save();
  bool load();

public:
  double		energy;
  float		confidence;
  intg		size; //! Number of samples seen for this iteration.
  intg		age;
  intg		total_correct;
  intg		total_error;
  intg		total_punt;
  double		total_energy;
  std::vector<uint>	class_errors;
  std::vector<uint>	class_totals;
  std::vector<uint>	class_tpr;
  std::vector<uint>	class_fpr;
  std::vector<std::string> log_fields; //!< Names of variables to log.
  std::vector<double> log_values; //!< Values to log.
  std::vector<double> total_values; //!< Totals samples used for values.
private:
  idx<int>		confusion;	//!< confusion matrix
  idx<int>            total_confusion;//!< Confusion matrix over all iterations.
  uint                nclasses;       //!< number of classes
};

} // namespace ebl

#include "ebl_logger.hpp"

#endif /* EBL_LOGGER_H_ */
